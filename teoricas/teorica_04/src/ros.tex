\begin{frame}
	\frametitle{Motivación}
	
	Don’t reinvent the wheel. Create something new and do it faster and better by building on ROS!
	
	\note{https://www.ros.org/blog/why-ros/}
	
	
	\note{https://www.youtube.com/watch?v=bFDfvKctvV8&list=PLRE44FoOoKf7NzWwxt3W2taZ7BiWyfhCp&index=1}
	
	\note{https://www.youtube.com/watch?v=O0729K-7VEY&list=PLNw2RD-1J5YYvFGiMafRD_axHrBUGvuIg&index=1}
	
	\note{https://youtu.be/ZQezxGadsqw}
	
\end{frame}

\begin{frame}
	\frametitle{¿Qué es ROS?}
	
	ROS (Robot Operating System) es un kit de desarrollo de software de código abierto para aplicaciones de robótica. ROS ofrece una plataforma de software estándar para desarrolladores de todas las industrias que los llevará desde la investigación y la creación de prototipos hasta la implementación y la producción.
	
	\begin{itemize}
		\item Comunidad global
		\item Utilizado en cursos de robótica, investigación e industria
		\item Acorta los tiempos de producción
		\item Multi-dominio: indoor / outdoor, hogareño / industrial, bajo el agua / espacio
		\item Multi-plataforma: Linux, Windows y macOS.
		\item Open-source
		\item Licencia permisiva (Apache 2.0)
		\item Soporte desde la industria
	\end{itemize}
	
	
	\note{https://www.ros.org/blog/why-ros/}
	
	
\end{frame}

\begin{frame}
	\frametitle{¿Qué es ROS?}
	  Trabajaremos con la versión Ubuntu LTS más actual, esta siempre viene con una versión de ROS estable.
	
	\begin{figure}[!h]
		\centering
		\subfloat[ROS1]
		{
			\includegraphics[width=0.4\columnwidth]{images/ros_version_noetic.png}
		}
		\subfloat[ROS2]
		{
			\includegraphics[width=0.4\columnwidth]{images/ros_version_humble.png}
		}
	\end{figure}

\end{frame}

\begin{frame}
	\frametitle{Configuración de entorno de ROS}
    
    \href{https://docs.ros.org/en/<distro>/Tutorials.html}{https://docs.ros.org/en/<distro>/Tutorials.html}
    
    Instalar ROS
    
    sudo apt install ros-<distro>-<package>
    
    Sourcear los archivos de setup
    
    source /opt/ros/<distro>/setup.bash
    
    Agregar el source al .bashrc
    
    echo "source /opt/ros/<distro>/setup.bash" >> ~/.bashrc
    
    Chequear las variables de entorno
    
    printenv | grep -i ROS
    
    Output:
    
    ROS\_VERSION=2\\
    ROS\_PYTHON\_VERSION=3\\
    ROS\_DISTRO=humble
    
    

    setear el DOMAIN ID:
    
    Los nodos ROS 2 en el mismo dominio pueden descubrir y enviarse mensajes libremente, mientras que los nodos ROS 2 en diferentes dominios no pueden. Todos los nodos ROS 2 utilizan el ID de dominio 0 de forma predeterminada.
    
    echo "export ROS\_DOMAIN\_ID=<your\_domain\_id>" >> ~/.bashrc
	
	
\end{frame}

\begin{frame}
	\frametitle{Ejemplo: talker y listener}
	
	En una terminal ejecutar (un talker en c++):
	
	source /opt/ros/<distro>/setup.bash
	
	ros2 run demo\_nodes\_cpp talker
	
	En otra terminal ejecutar (un listener en python):
	
	source /opt/ros/<distro>/setup.bash
	
	ros2 run demo\_nodes\_py listener
	
\end{frame}

\begin{frame}
    \frametitle{Turtlesim}
    
    sudo apt install ros-humble-turtlesim
    
    Verificamos los 
    ros2 pkg executables turtlesim
    output:
    
    turtlesim draw\_square
    turtlesim mimic
    turtlesim turtle\_teleop\_key
    turtlesim turtlesim\_node
    
    ros2 run turtlesim turtlesim\_node
    
    ros2 run turtlesim turtle\_teleop\_key
    
    ros2 node list
    ros2 topic list
    ros2 service list
    ros2 action list
    
    Abrir rqt
    Plugins > Services > Service Caller y y spawn un nueva tortuga.
    
    ros2 run turtlesim turtle\_teleop\_key --ros-args --remap turtle1/cmd\_vel:=turtle2/cmd\_vel
    

\end{frame}

\begin{frame}
    \frametitle{ROS graph}
    El grafo de ROS es una red de elementos ROS 2 que procesan datos juntos al mismo tiempo. Abarca todos los ejecutables y las conexiones entre ellos si tuviera que mapearlos y visualizarlos.
    
    Cada nodo en ROS debe ser responsable de un solo propósito de módulo (por ejemplo, un nodo para controlar los motores de las ruedas, un nodo para controlar un telémetro láser, etc.). Cada nodo puede enviar y recibir datos a otros nodos a través de tópicos, servicios, acciones o parámetros.
    
    Un sistema robótico completo se compone de muchos nodos que trabajan en conjunto. En ROS 2, un único ejecutable (programa C++, programa Python, etc.) puede contener uno o más nodos.
    
    \TODO{Agregar imagen de comunicación de ROS}
\end{frame}

\begin{frame}
    \frametitle{Volvamos al Turtlesim para ver otros conceptos}
    
    El comando ros2 run corre un ejecutable desde un paquete.
    
    ros2 run <package\_name> <executable\_name>
    
    La ros2 node list muestra los nombres de todos los nodos en ejecución.
    
    ros2 node list
    
    Remapping permite mapear propiedades de nodo predeterminadas, como nombre de nodo, nombres de tópicos, nombres de servicio, etc., a valores personalizados.
    
    ros2 run turtlesim turtlesim\_node --ros-args --remap \_\_node:=my\_turtle
    
    ros2 node info <node\_name>
    
\end{frame}

\begin{frame}
    \frametitle{Volvamos al Turtlesim para ver otros conceptos (cont.)}
    
    Visualizar los nodos y la comunicación entre los mismos:
    
    rqt\_graph
    
    Devuelve la misma lista de tópicos, esta vez con el tipo de tema entre paréntesis:
    
    ros2 topic list -t
    
    Ver los datos publicados en un tópico:
    
    ros2 topic echo <topic\_name>
    
    Ejemplo:
    
    ros2 topic echo /turtle1/cmd\_vel
    
    Obtener información acerca de los publicadores y subscriptores de un tópico:
    
    ros2 topic info
    
    Obtener detallels sobre un tipo de mensaje:
    
    ros2 interface show <msg type>
    
    Ejemplo:
    
    ros2 interface show geometry\_msgs/msg/Twist
    
    Publicar mensajes utilizando la línea de comandos:
    
    ros2 topic pub <topic\_name> <msg\_type> '<args>'
    
    Ejemplo:
    
    ros2 topic pub --rate 1 /turtle1/cmd\_vel geometry\_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
    
    Saber la prefuencia en que se publica un mensaje
    ros2 topic hz <topic\_name>
    
\end{frame}

\begin{frame}
	\frametitle{Archivos launch}
	
	A medida que se crean sistemas más complejos con más y más nodos ejecutándose simultáneamente, abrir terminales y volver a ingresar los detalles de configuración se vuelve tedioso.
	
	Los archivos launch permiten iniciar y configurar varios ejecutables que contienen nodos ROS 2 de manera simultáneamente.
	
	Ejecutar un solo archivo launch con el comando ros2 launch iniciará todo su sistema, todos los nodos y sus configuraciones, a la vez.
	
    Correr un archivo launch

	ros2 launch <package\_name> <launch\_file\_name> <launch\_arguments>

	Ejemplo:

	ros2 launch turtlesim multisim.launch.py
	
\end{frame}


\begin{frame}
    \frametitle{Crear workspace}
    
    Un workspace es un directorio que contiene paquetes de ROS 2. Antes de usar ROS 2, es necesario obtener su espacio de trabajo de instalación de ROS 2 en la terminal en la que planea trabajar. Esto hace que los paquetes de ROS 2 estén disponibles para que los use en esa terminal.
    
    mkdir -p ~/dev\_ws/src\\
    cd ~/dev\_ws/src
    
    Agregar un paquete de ejemplo al workspace (dentro de ~/dev\_ws/src)
    
    git clone https://github.com/ros2/examples examples -b <distro>
    
    
    git clone https://github.com/ros/ros\_tutorials.git -b <distro>-devel
    
 
\end{frame}


\begin{frame}
	\frametitle{Compilar el workspace}

	Instalar colcon
	
	sudo apt install python3-colcon-common-extensions
	
	En la raíz del worklspace, ejecutar
	
	colcon build --symlink-install
	
	El flag --symlink-install permite usar enlaces simbólicos en lugar de copiar archivos a las carpetas de ROS2 durante la instalación, siempre que sea posible. Cada paquete en ROS2 debe instalarse y todos los archivos utilizados por los nodos deben copiarse en las carpetas de instalación.
	
	El build genera los directorios: build, install y log.
	
	Cuando colcon haya completado el build, la salida estará en el directorio de install.  colcon genera archivos bash/bat en el directorio install para ayudar a configurar el entorno. Estos archivos agregarán todos los elementos requeridos a su ruta y rutas de biblioteca, así como también proporcionarán cualquier comando bash o shell exportado por los paquetes.
	
	Ejemplo de uso: (no olvidar source install/setup.bash)
	
	ros2 run examples\_rclcpp\_minimal\_subscriber subscriber\_member\_function
	
	ros2 run examples\_rclcpp\_minimal\_publisher publisher\_member\_function
	
	El comando colcon\_cd le permite cambiar rápidamente el directorio de trabajo actual al de un paquete.
	
\end{frame}


\begin{frame}
	\frametitle{Creando un paquete en ROS2}
	
     Building system: ament
     luego para compilar un paquete: colcon build
     
     
     crear un paquete:
     
     ros2 pkg create test\_pkg --build-type ament\_cmake
     
     ros2 pkg create test\_pkg --build-type ament\_cmake --node-name <node\_name> <package\_name>
	
\end{frame}

\begin{frame}
	\frametitle{Rosbag}
	ros2 bag es una herramienta de línea de comandos para registrar datos publicados sobre temas en su sistema. Acumula los datos transmitidos sobre cualquier número de tópicos y los guarda en una base de datos. Luego puede reproducir los datos para reproducir los resultados de sus pruebas y experimentos. Grabar temas también es una excelente manera de compartir su trabajo y permitir que otros lo recreen.
	
	ros2 bag record <topic\_name>
	
	ros2 bag info <bag\_file\_name>
	
	ros2 bag play <bag\_file\_name>
	
	ros2 bag compress <bag\_file\_name>
	
	ros2 bag decompress <bag\_file\_name>
	
\end{frame}

\begin{frame}
	\frametitle{Cómo escribir un Publicador y un subscriptor}

\end{frame}


\begin{frame}
	\frametitle{Install turtlebot en ROS}
	
\end{frame}

\begin{frame}
	\frametitle{Publicar velocidades a Turtlebot}
	
\end{frame}

\begin{frame}
	\frametitle{TF}
	Hablar de las TF de ROS.
	
\end{frame}

\begin{frame}
	\frametitle{RViz}
	topic node hz echo Bw etc...
	
\end{frame}

\begin{frame}
    \frametitle{rqt\_bag}

    
\end{frame}

\begin{frame}
	\frametitle{Crear mensajes customizados}
	Hablar de las TF de ROS.
	
\end{frame}

\begin{frame}
	\frametitle{Herramientas por línea de comandos útiles}
    topic node hz echo Bw etc...
    ros2 <hit\_tab>
    ros2 topic list
    ros2 bag 
	
\end{frame}

\begin{frame}
    \frametitle{Estrategias de Debugging}
    
    \note{información extraida de https://youtu.be/ZQezxGadsqw}
    \begin{itemize}
        \item Compilar y correr código frecuentemente para atrapar errores tempranamente
        \item Entender los mensajes de error de compilación y ejecución
        \item Usar herramientas de análisis para verificar el flujo de los datos: ros2 node info, ros2 topic echo, ros2 wtf, rqt\_graph, etc.
        \item Visualizar y plotear los datos: RViz, RQT Multiplot, rqt\_bag, etc.
        \item Dividir el programa en pequeños pasos y verificar resultados intermedios (ROS\_INFO, ROS\_DEBUG, etc)
        \item Hacer el código robusto verificando argumentos de entrada y utilizar try-catch para atrapar excepciones
        \item Extender y optimizar el código solo cuando la versión básica este funcionando
        \item si las cosas no tienen sentido, limpiar el workspace
        \item Debugguear con una IDE (utilizar breakpoints)
        \item Escribit Unit-tests y test de integración para encontrar regresiones
    \end{itemize}
    
\end{frame}
