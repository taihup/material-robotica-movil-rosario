\documentclass[tp]{lcc}

% add latex preamble
\input{../../common/latex_preamble}

% add math preamble
\input{../../common/math_preamble}

\codigo{R-521}
\materia{Robótica Móvil}
\titulo{EKF para Localización de un Robot Móvil}

\soluciones
\commentstrue


\usepackage{biblatex}
%\addbibresource{refs.bib}

\begin{document}
	\maketitle
	
	
	\section{Introducción}
	
	El objetivo del Trabajo Práctico es comprender cómo funciona EKF para la localización de un robot móvil y desarrollar una implementación del mismo.
	
	Para este trabajo se utilizará el framework de Python provisto por la cátedra. Sin embargo, se alienta a que el trabajo se desarrolle en ROS2 y Gazebo. \footnote{Este trabajo práctico está basado en el Homework 2 del curso CSE571: Probabilistic Robotics of University of Washington - Paul G. Allen School of Computer Science \& Engineering \url{https://courses.cs.washington.edu/courses/cse571/20sp/homeworks/HW2.pdf}.}
	
	Material de lectura útil: slides de las clases, Capítulos 3, 4, 5, 7 y 8 del libro Probabilistic Robotics, Thrun, Burgard and Fox.
	
	
	\section{Entrega}
	\begin{itemize}
		\item Se debe proveer un repositorio git que contenga el código desarrollado, una imagen docker y un archivo \lstinline{README.md} con las instrucciones de compilación y ejecución.
		
		\item Se debe entregar un informe en Lyx o \LaTeX\  explicando el trabajo realizado y analizando los resultados obtenidos.
	\end{itemize}

	
	\section{Enunciado}
		
	Implementar un Filtro de Kalman Extendido (EKF) y un Filtro de Partículas (PF) para localizar un robot basado en \emph{landmarks}. Usaremos el modelo de movimiento basado en la odometría que derivó en la pregunta 1.2. Suponemos que hay landmarks presentes en el entorno del robot. El robot recibe los ángulos (\emph{bearing}) a los landmarks y los ID de los landmarks como observaciones: (orientación, ID de landmark).
	
	Asumimos un modelo de ruido para el modelo de movimiento de odometría con parámetros $\alpha$ (PR Tabla 5.6) y un modelo separado modelo de ruido para las observaciones de rumbo con parámetro $\beta$ (PR Sección 6.6). La observación de ID de punto de referencia es sin ruido. Consulte el código de inicio proporcionado para obtener detalles de implementación.
	
	En cada paso de tiempo, el robot comienza desde el estado actual y se mueve de acuerdo con la entrada de control. El robot luego recibe una observación histórica del mundo. Utilizará esta información para localizar el robot sobre el
	secuencia de tiempo completo con un EKF y PF.
	
	\begin{figure}[!htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{./images/odometry_as_controls.pdf}
		\label{fig:odometry-base-motion-model}
	\end{figure}

	\section{Descripción del código}
	
	El código de inicio está escrito en Python y depende de NumPy y Matplotlib.
	
	\begin{itemize}
	\item \lstinline[style=bash]{localization.py} --- principal punto de entrada para ejecutar experimentos.
	\item \lstinline[style=bash]{soccer_field.py} --- implementa las funciones del modelo dinámico y observación, así como los modelos de ruido para ambos. ¡Implementar los jacobianos acá!
	\item \lstinline[style=bash]{utils.py} --- contiene varias funciones de visualización, así como una función útil para normalizar un ángulo entre $[-\pi, \pi]$.
	\item \lstinline[style=bash]{policy.py} --- contiene una política simple que puede ignorar sin problemas.
	\item \lstinline[style=bash]{ekf.py} --- ¡Implementar acá el Filtro de Kalman Extendido!
	\item \lstinline[style=bash]{pf.py} --- ¡Implementar acá el Filtro Partículas!
	\end{itemize}

	\section{Interfaz de comando}

	Para visualizar el robot en el entorno del campo de fútbol, ejecute
	
\begin{lstlisting}[style=bash] 
python localization.py --plot none
\end{lstlisting}

	
	La línea azul traza la posición del robot, que es el resultado de acciones ruidosas. La línea verde traza el robot posición asumiendo que las acciones no eran ruidosas. Después de implementar un filtro, la estimación del filtro del robot la posición se dibujará en rojo.
	
	
\begin{lstlisting}[style=bash] 
python localization.py --plot ekf
python localization.py --plot pf
\end{lstlisting}

Para ver otras banderas de línea de comandos disponibles para usted, ejecute

\begin{lstlisting}[style=bash] 
python localization.py -h
\end{lstlisting}

\section{Formato de los datos}

\begin{itemize}
	\item estado: $[x,y,\theta]$
	\item control: $[\delta_{rot1},\delta_{trans},\delta_{rot2}]$
	\item observación: $[\theta_{bearing}]$
\end{itemize}

\section{Notas}
\begin{itemize}
	\item Llamar a \lstinline[style=bash]{utils.minimized_angle} cada vez que un ángulo o una diferencia de ángulo pueda exceder $[-\pi, \pi]$.
	\item Utilizar el muestreador sistemático de baja varianza de clase. Te da una distribución más suave de partículas y también requiere un único número aleatorio por paso de remuestreo.
	\item Desactivar la visualización para una acelerar la ejecución.
\end{itemize}

\ejercicio Implementar EKF
Implemente el algoritmo de filtro de Kalman extendido en ekf.py. Deberá completar ExtendedKalmanFilter.update
y los métodos de campo G, V y H. Sus resultados de una implementación exitosa de EKF deben ser comparables
a los siguientes resultados.

\begin{lstlisting}[style=bash] 
python localization.py ekf --seed 0
...
Mean position error: 8.9983675360847
Mean Mahalanobis error: 4.416418248584298
ANEES: 1.472139416194766
\end{lstlisting}


\begin{enumerate}
	\item Trace la ruta del robot real y la ruta del filtro con los parámetros predeterminados (proporcionados).
	\item  Grafique el error de posición medio a medida que los factores $\alpha$ y $\beta$ varían sobre $r = [1/64, 1/16, 1/4, 4, 16, 64]$\footnote{Dado que los factores se multiplican con varianzas, esto es entre 1/8 y 8 veces los valores de ruido predeterminados.} y analice cualquier cosa interesante que observes.
	
	Debe ejecutar 10 ensayos por valor de $r$. Una ejecución podría ser algo como:

\begin{lstlisting}[style=bash] 
python localización.py ekf --factor de datos 4 --factor de filtro 4
\end{lstlisting}

	\item Trace el error de posición medio y ANEES (error de estimación normalizado promedio al cuadrado) como el filtro $\alpha$, $\beta$ los factores varían sobre $r$ (como arriba) mientras que los datos se generan con el valor predeterminado. Habla de cualquier cosa que te interese observar.
\end{enumerate}


\ejercicio Implementar PF

Implemente el algoritmo de filtro de partículas en pf.py. Deberá completar ParticleFilter.update y ParticleFilter.resample.

\begin{lstlisting}[style=bash] 
python localization.py pf --seed 0
...
Mean position error: 8.567264372950905
Mean Mahalanobis error: 14.742252771106532
ANEES: 4.914084257035511
\end{lstlisting}

\begin{enumerate}
	\item Trace la ruta del robot real y la ruta del filtro con los parámetros predeterminados.
	\item Grafique el error de posición medio a medida que los factores $\alpha$, $\beta$ varían sobre $r$ y analice.
	\item Grafique el error de posición medio y ANEES como el filtro $\alpha$, los factores $\beta$ varían sobre $r$ mientras se generan los datos
	con el valor predeterminado.
	\item Grafique el error de posición medio y ANEES a medida que los factores $\alpha$, $\beta$ varían sobre $r$ y el número de partículas varía
	sobre $[20, 50, 500]$.
\end{enumerate}


\printbibliography
	
\end{document}
