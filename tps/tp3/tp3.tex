\documentclass[tp]{lcc}

% add latex preamble
\input{../../common/latex_preamble}

% add math preamble
\input{../../common/math_preamble}

\codigo{R-521}
\materia{Robótica Móvil}
\titulo{Visión por Computadora: Triangulación y Proyección}

\soluciones
\commentstrue


\usepackage{biblatex}
%\addbibresource{refs.bib}

\begin{document}
\maketitle

\section{Introducción}

El objetivo del trabajo práctico es la realización de los pasos básicos para poder triangular y proyectar puntos con una cámara estéreo. En este trabajo se debe utilizar  las librerías OpenCV\footnote{\url{https://opencv.org/}} y software de calibración ampliamente utilizado en el campo de visión por computadora y robótica.


\section{Entrega}
\begin{itemize}
	\item Se debe proveer un repositorio git que contenga el código desarrollado, una imagen docker y un archivo \lstinline{README.md} con las instrucciones de compilación y ejecución.
	\item Además, se deberá entregar un informe realizado en Lyx o latex explicando los pasos realizados y analizando los resultados obtenidos.
\end{itemize}

\section{Datos}
Para trabajar se utilizarán los datos del dataset EuRoC\footnote{\url{https://projects.asl.ethz.ch/datasets/doku.php?id=kmavvisualinertialdatasets}} pero en formato rosbag de ROS2 que pueden ser descargado de \url{https://docs.openvins.com/gs-datasets.html}

\section{Calibración}
Antes de comenzar a trabajar con un dataset se debe realizar una calibración de los sensores. En este trabajo solo deben calibrar una cámara estéreo.

Para la calibración se puede utilizar cualquiera de las aplicaciones que se detallan a continuación:
\begin{itemize}
	\item ROS2 camera\_calibration:  \url{https://navigation.ros.org/tutorials/docs/camera_calibration.html}
	\item OpenCV tutorial\_camera\_calibration:\\ \url{https://docs.opencv.org/4.x/d4/d94/tutorial_camera_calibration.html}
	\item Kalibr: \url{https://github.com/ethz-asl/kalibr/wiki/ROS2-Calibration-Using-Kalibr}
	\item Camera Calibration Toolbox for Matlab:\\ \url{https://www.cs.toronto.edu/pub/psala/VM/cameraCalibrationExample.html}
\end{itemize}

Desarrollar un programa que lea un par de imágenes estéreo cualquiera y realice los siguientes pasos:

\section{Rectificación de imágenes}
Con los parámetros íntrinsecos y extrínsecos de la cámara estéreo, rectificar un par imágenes haciendo uso de la librería OpenCV. Para esto se deberan utilizar las funciones:  \lstinline{cv::stereoRectify()},  \lstinline{cv::initUndistortRectifyMap()} y  \lstinline{remap()}.

\section{Extracción de feaures: Keypoints y descriptores}
Selecionar un detector de keypoints (FAST, ORB, SIFT, SURF, GFTT, BRISK, etc.) y un descriptor (BRIEF, ORB, BRISK, etc.), y extraer features en ambas imágenes.

\section{Búsqueda de correspondencias visuales}
Realizar la búsqueda de correspondencias entre los feature de ambas imágenes (\emph{matching}). Para esto se debe utilizar la función \lstinline{cv::BFMatcher::BFMatcher()}. 

\section{Triangulación de puntos 3D}
Dadas las correspondencia visuales (\emph{matches}) obtenidas en el paso anterior, realizar la triangulación de los features detectados utilizando la función \lstinline{cv::sfm::triangulatePoints()}.

\section{Filtrado de correspondencias espúreas}
Aplicar RANSAC (\emph{Random sample consensus}) para filtrar los matches espúreos y computar la Matríz Fundamental. Para esto puede utilizar la función \lstinline{cv::findHomography()}.

\section{Computar el mapa de disparidad}
Computar el mapa de disparidad con las librerías utilizando la función \lstinline{cv::StereoMatcher::compute()}. Opcionalmente para tener mejores resultados puede utilizar la librería LIBELAS\footnote{\url{http://www.cvlibs.net/software/libelas/}}.

\section{Reconstrucción 3D densa}
Utilizando el mapa de disparidad obtenido en el paso anterior realizar una reconstrucción densa de la escena observada utilizando la función \lstinline{cv::reprojectImageTo3D()}. Para esto debe utilizar la matríz de reproyección Q retornada por la función \lstinline{cv::stereoRectify()}.

\section{Estimación de pose Monocular}
Utilizando \lstinline{cv::recoverPose()} estimar la transformación entre la imagen izquierda y la imagen derecha. Para esto deberá calcular la matríz esencial utilizando la función \lstinline{cv::findEssentialMat()}.

\end{document}
